// ------------------------------------------
//  Created by Jean-Michel Bruel on 2014-11.
//  Copyright (c) 2014 IRIT/U. Toulouse. All rights reserved.
// ------------------------------------------
= Design patterns
ifndef::myasciidoconf[]
Jean-Michel Bruel (@jmbruel, jbruel@gmail.com)
v1.0, {localdate} - First draft
:experimental:
:numbered!:
:deckjs_theme: swiss
:status: bottom

include::asciidoc.conf[]

endif::myasciidoconf[]

ifndef::definitions[]
include::definitions.txt[]
endif::definitions[]

ifdef::inclusion[]
ifdef::slides[:leveloffset: -1]
endif::inclusion[]

:pattern-list:

== Introduction : importance des patrons

ifndef::slides[.Les patrons : des réponses éprouvées à des problèmes récurrents]
image::phdComics.png[]

[quote,Donald Knuth]
_______________________
Science is what we understand well enough to explain to a computer.
Art is everything else we do.
_______________________

== Point sur le TD de la semaine passée

ifdef::slides[:leveloffset: -1]

=== Principes de conception

[icon="{iconsdir}/yinyang.jpeg"]
[NOTE]
.Principe de conception
====
[quote]
____________________________________________________________________
Identifiez les apsects de votre code qui varient et
séparez-les de ceux qui demeurent constant.
____________________________________________________________________
====

ifdef::slides[=== Principes de conception (suite)]

[icon="{iconsdir}/yinyang.jpeg"]
[NOTE]
.Principe de conception
====
[quote]
____________________________________________________________________
Programmer une interface, non une implémentation.
____________________________________________________________________
====

ifdef::slides[=== Principes de conception (suite)]

[icon="{iconsdir}/yinyang.jpeg"]
[NOTE]
.Principe de conception
====
[quote]
____________________________________________________________________
Préférez la composition à l'héritage.
____________________________________________________________________
====

=== Premier patron

[icon="{iconsdir}/pattern.jpeg"]
[NOTE]
.Design pattern : *Stratégie* (_Strategy_)
====
include::pattern/strategy.txt[]
====

=== Premier exemple d'utilisation de patron

ifndef::slides[.Premier exemple d'utilisation de patron]
image::superCanardFinal.png[link="images/superCanardFinal.png"]

WARNING: Pourquoi n'a-t'on pas utilisé _Strategy_ pour `afficher()` ou `nager()`?

=== Autre exemple concret

NOTE: Cet exemple est tiré de
http://openclassrooms.com/courses/programmez-en-oriente-objet-en-php/les-design-patterns[ce cours].

*Le problème*

Vous avez une classe `FileWriter` qui a pour rôle d'écrire dans un fichier
ainsi qu'une classe `DBWriter`. Dans un premier temps, ces classes ne
contiennent qu'une méthode `write()` qui n'écrira que le texte passé
en paramètre.

Au fil du temps, vous vous rendez compte que c'est dommage qu'elles ne
fassent que ça et vous aimeriez bien qu'elles puissent écrire en différents
formats (HTML, XML, etc.) : les classes doivent donc formater puis écrire.

ifdef::slides[=== Autre exemple concret (suite)]

*La solution*

ifndef::slides[.Application du pattern <<strategy>> (http://openclassrooms.com/courses/programmez-en-oriente-objet-en-php/les-design-patterns[source])]
image::strategyWriter.png[link="http://openclassrooms.com/courses/programmez-en-oriente-objet-en-php/les-design-patterns"]

ifdef::slides[=== Autre exemple concret (suite)]

[icon="images/formater-icon.png"]
[NOTE]
====
.L'interface en `PHP` (code source link:src/php/Formater.php[ici])
[source,php]
------
include::src/php/Formater.php[]
------
====

ifdef::slides[=== Autre exemple concret (suite)]

[icon="images/writer-icon.png"]
[NOTE]
====
.La classe abstraite `Writer` (code source link:src/php/Writer.php[ici])
[source,php]
------
include::src/php/Writer.php[]
------
====

ifdef::slides[=== Autre exemple concret (suite)]

[icon="images/filewriter-icon.png"]
[NOTE]
====
.La classe `FileWriter` (code source link:src/php/FileWriter.php[ici])
[source,php]
------
include::src/php/FileWriter.php[]
------
====

ifdef::slides[=== Autre exemple concret (suite)]

[icon="images/dbwriter-icon.png"]
[NOTE]
====
.La classe `DBWriter` (code source link:src/php/DBWriter.php[ici])
[source,php]
------
include::src/php/DBWriter.php[]
------
====

ifdef::slides[=== Autre exemple concret (suite)]

Enfin, nous avons nos trois formateurs.
L'un ne fait rien de particulier (`TextFormater`),
et les deux autres formatent le texte en deux langages
différents (`HTMLFormater` et `XMLFormater`).

ifdef::slides[=== Autre exemple concret (suite)]

[icon="images/formaters-icon.png"]
[NOTE]
====
.La classe `TextFormater` (code source link:src/php/TextFormater.php[ici])
[source,php]
------
include::src/php/TextFormater.php[]
------

ifdef::slides[]
====

=== Autre exemple concret (suite)

[icon="images/formaters-icon.png"]
[NOTE]
====

endif::slides[]

.La classe `HTMLFormater` (code source link:src/php/HTMLFormater.php[ici])
[source,php]
------
include::src/php/HTMLFormater.php[]
------

ifdef::slides[]
====

=== Autre exemple concret (suite)

[icon="images/formaters-icon.png"]
[NOTE]
====

endif::slides[]

.La classe `XMLFormater` (code source link:src/php/XMLFormater.php[ici])
[source,php]
------
include::src/php/XMLFormater.php[]
------
====

=== D'autres exemples

[%step]
- La fonction standard `sort()` de python
+
[source,python]
-------------
>>> sorted("This is a test string from Andrew".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']
-------------
+
- Stratégie de cryptage en fonction de la taille d'un fichier
+
[source,java]
-------------
File file = getFile();
 Cipher c = CipherFactory.getCipher( file.size() );
 c.performAction();

// implementations:
interface  Cipher  {
     public void performAction();
}
class InMemoryCipherStrategy implements Cipher {
         public void performAction() {
             // load in byte[] ....
         }
}
class SwaptToDiskCipher implements Cipher {
         public void performAction() {
             // swapt partial results to file.
         }
}
-------------

TIP: Plus de détails http://stackoverflow.com/questions/370258/real-world-example-of-the-strategy-pattern[ici]

=== (non) Réutilisation

WARNING: Les patrons *ne sont pas réutilisables*!

Il faut implémeter la solution qu'il représente à chaque fois.

ifdef::slides[=== Réutilisation (exception)]

Exception : certains font l'objet d'une librairie.

Par exemple le patron Singleton existe dans la bibliothèque standard du
langage  en {Ruby}.
C'est un mixin qu'il suffit d'inclure dans la classe qui doit être un singleton.

[source,ruby]
------
class Klass
   include Singleton
   # ...
end

a,b  = Klass.instance, Klass.instance

a == b
# => true

Klass.new
# => NoMethodError - new is private ...
------

=== Association ou composition

On trouve deux modèles {uml} :

ifndef::slides[._Strategy_  et composition]
image::strategy-compo.png[]

ifndef::slides[._Strategy_  et association]
image::strategy-assoc.png[]

ifdef::slides[=== Association ou composition (suite)]

Et donc deux implémentations :

.Composition => le composé encapsule les composants
[source,java]
------
public class Colvert extends Canard {

	protected Colvert() {
		this(new VolerAvecDesAiles(), new Cancan());
	}
...
c1 = new Colvert();
------

.Association => le composant existe "en dehors"
[source,java]
------
...
vol = new VolerAvecDesAiles();
cri = new Cancan();
c1 = new Colvert(vol,cri);
...
------

ifdef::slides[:leveloffset: +1]

== Un peu d'histoire

1977::
  *Alexander* : patterns pour les architectures (les vraies)
  image:Alexander.png[width=10%,link=images/Alexander.png]
1987::
  *Beck* et *Cunningham* : patterns pour des interfaces utilisateurs
1988::
  *Meyer* : livre sur l'orienté objet (langage {eiffel}), devenu la bible pour
  beaucoup de programmeurs (cf. <<Meyer88>>)
1990-1995::
  *Gamma*, Helm, Johnson et Vlissides : LE livre de référence (cf. <<GoF>>)
  image:GoF.png[width=10%,link=images/GoF.png]
2003::
  *Martin* : principes SOLID (cf. <<Martin03>>)
2004::
  *Craig Larman* décrit des modèles de conception : les Patterns *GRASP* (cf. <<Larman05>>)

NOTE:  Les patterns de ce livre sont connus comme les *Gof* pour « _Gang of Four_ ».

== Exemples de bons principes

*SOLID*:

- _**S**ingle Responsibility Principle_
- _**O**pen-Closed Principle_
- _**L**iskov Substitution Principle_
- _**I**nterface Segregation Principle_
- _**D**ependency Inversion Principle_

ifdef::slides[:leveloffset: -1]

=== _**S**ingle Responsibility Principle_

image::solid-s.jpg[]

.......
Responsabilité => Sujet à changement
.......

=== _**O**pen-Closed Principle_

image::solid-o.jpg[]

.......
Ouvert à l'extension mais fermé à la modification
.......

ifdef::slides[=== _**O**pen-Closed Principle_ (suite)]

TIP: Une fois écrite et testée, une classe ne devrait être modifiée que pour
être corrigée! Toute modification devrait être possible par extension.

=== _**L**iskov Substitution Principle_

image::solid-l.jpg[]

.......
Une classe doit pouvoir être remplacée par une instance d'un de ses
sous-types, sans modifier la cohérence du programme
.......

ifdef::slides[=== LSP : un exemple]
[quote]
__________________
Un carré est un rectangle a deux côtés égaux.
__________________

ifndef::slides[.Exemple classique de violation du principe de substitution de Liskov]
image::carre.png[width=10%]

WARNING: Peut-on toujours substituer un `Carré` à la place d'un `Rectangle` ?



=== _**I**nterface Segregation Principle_

image::solid-i.jpg[]

.......
Préférer plusieurs interfaces spécifiques pour chaque client plutôt qu'une
seule interface générale
.......

=== _**D**ependency Inversion Principle_

image::solid-d.jpg[]

.......
Il faut dépendre des abstractions, pas des implémentations
.......

ifdef::slides[=== DIP : explications]

Ce principe indique :

- Les modules de haut niveau (abstraits) ne doivent pas dépendre des modules de bas niveau.
Les deux doivent dépendre d'abstractions.
- Les abstractions ne doivent pas dépendre des détails d'implémentation.
C'est l'inverse : les détails doivent dépendre des abstractions.

NOTE: Ainsi ce principe va à l'encontre de l'intuition classique.

=== SOLID et patrons

[icon="{iconsdir}/tuxteacher.png"]
[IMPORTANT]
.*QUESTION*
====
Lesquels des 5 principes SOLID s'appliquent bien à _Strategy_ ?
====

//----------------------------------------------------- Correction -------------------------
ifdef::slides[=== SOLID et patrons (éléments de réponses)]
ifdef::prof[]
Quelques éléments de réponses :

[%step]
_**S**ingle Responsibility Principle_::
  Bof
_**O**pen-Closed Principle_::
  => *Oui* : extension (du comportement) sans toucher au code!
_**L**iskov Substitution Principle_::
  Non
_**I**nterface Segregation Principle_::
  Oui, mais pas spécifiquement
_**D**ependency Inversion Principle_::
  => *Oui* : les algos dépendent des mêmes abstractions que les données (les interfaces)

endif::prof[]
//----------------------------------------------------- Correction -------------------------

ifdef::slides[:leveloffset: +1]

== GRASP

[quote,Craig Larman,2005]
________________
The critical design tool for software development is *a mind well educated in
design principles*. It is not the UML or any other technology.
________________

Il s'agit d'un ensemble de patrons, plutôt orientés conception (UML). Nous en
aborderons certains au travers des exemples de ce module (cf. <<Larman05>>).

== Les patrons : comment ça marche ?

ifdef::slides[:leveloffset: -1]

=== Intérêt

- Réponses éprouvées à des problèmes récurrents
- Vocabulaire commun

[quote]
___________________
T'as qu'à utiliser une _factory_!
___________________

ifdef::slides[]

//----------------------------- Question ------------------
.*QUESTION*
[WARNING]
====
Qui fait la nuit de l'info dans un groupe avec des Masters?

image::N2I.png[width=20%]
====

endif::slides[]

=== Définifion

- Nom
- Problème
- Solution
- Conséquences

Exemple de _Strategy_ :

*Nom*:: _Strategy_
*Problème*::  Situations où il est nécessaire de pouvoir définir dynamiquement les
            algorithmes utilisés.
*Solution*::  Définir une famille d'algorithmes, encapsuler chacun d'eux en tant
            qu'objet, et les rendre interchangeables.
*Conséquences*::  Ce patron laisse les algorithmes changer indépendamment des
                clients qui les emploient.

=== Patrons à aborder

[%step]
* Ceux déjà pratiqués
** <<Singleton>>
** <<Observateur>>
** <<Fabrique>> (_factory_) (cf. parser sax)

ifdef::slides[=== Patrons à aborder]

* Les "pressentis"
- <<Stratégie>>
- Itérateur
- Composite
- Etat
- Proxy

ifdef::slides[=== Patrons à aborder]

* Les nouveaux
- Décorateur
- Commande
- Adaptateur
- Façade
- Patron de méthode

ifdef::slides[=== Patrons à aborder]

* Les "avancés"
- Chaînes de responsabilité
- Visiteur

ifdef::slides[=== Patrons à aborder]

* Ceux qu'on n'aura pas le temps d'aborder
- Prototype
- Mémento
- Médiateur
- Interprète
- Poids-mouche
- Monteur
- Pont

ifdef::slides[=== Patrons à aborder]

* Concepts avancés
- Patrons de patrons (exemple du MVC)
- Anti-patrons

ifdef::slides[]

ifdef::slides[:leveloffset: +1]

== Time for a quizz!

//----------------------------- Question ------------------
[icon="{iconsdir}/tuxteacher.png"]
.*QUESTION*
[WARNING]
====

- Connectez-vous sur : http://www.socrative.com/ (*student login*)
- Ou téléchargez l'application pour étudiant image:socrative2.png[width=10%]
- Choisissez la room *44918d67*
====

image::socrative1.png[width=50%,link=http://www.socrative.com/]

== Quizz

image::quizz1.png[]

== Quizz

image::quizz2.png[]

== Quizz

image::quizz3.png[]

== Quizz

image::quizz4.png[]

== Quizz

image::quizz5.png[]

== Quizz

image::quizz6.png[]

== Quizz

image::quizz7.png[]

== Quizz

image::quizz8.png[]

== Quizz

image::quizz9.png[]

== Quizz

image::quizz10.png[]

== Quizz

image::quizz11.png[]

== Quizz

image::quizz12.png[]

== Quizz

image::quizz13.png[]

endif::slides[]

[appendix]
:numbered!:
include::glossaire.txt[]

include::refs.txt[]

include::conventions.txt[]

include::creditPhoto.txt[]

ifdef::inclusion[]

ifdef::slides[:leveloffset: +1]

endif::inclusion[]
