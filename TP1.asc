:moduleTitle: CPOA
:authorDefault:  Dut/Info-S3/M3105
:tdnum: TP 1

:eleve:
:sourcedir: src/java/TD1

ifndef::definitions[]
include::definitions.txt[]
endif::definitions[]
ifndef::myasciidoconf[]
include::asciidoc.conf[]
endif::myasciidoconf[]

ifdef::eleve[]
:doctitle:  {moduleTitle} - Sujet {tdnum}
endif::eleve[]
ifdef::prof[]
:doctitle: {moduleTitle} - Support {tdnum}
endif::prof[]
ifdef::todoprof[]
:doctitle: {moduleTitle} - DEROULEMENT SEANCE PROF {tdnum}
endif::todoprof[]

:icons: font

= {doctitle}
:Author:  {authorDefault} - (Semaine 46)
:lang: fr
:incremental:
:experimental:
:date: {localdate}

// eleve : sujet pour élèves
// prof : support prof pour séance
// todoprof : support AVEC EXPLICATIOSN DEROULEMENT pour profs

//----------- définitions --------------
:sitecours: http://jmbruel.github.io/cpoa/[Support de Cours]
:pre: PreReq
:objtd: ObjTD
:duree: Durée
:depot: À rendre
:lien: Lien
:img: img

//-------------------- Warning si correction -----------
ifdef::prof[]
[CAUTION]
.Version corrigée
=====
Cette version comporte des indications pour les
réponses aux exercices.
=====
endif::prof[]

//-------------------- Cartouche d'en-tête -----------
[[cartouche]]
[align="left",cols="1,10a",width="90%"]
|======================
| {pre}		|
. Je sais programmer en {java}.
. J'ai conscience qu'il faut réfléchir avant de se lancer dans le codage.
. Je maîtrise les concepts objet de base (héritage, polymorphisme, ...).
. J'ai réalisé le TD `SuperCanard` et donc connait le patron _Strategy_!
| {objtd}	| Comprendre ce qu'est une *conception* et implémenter mon premier patron.
| {duree}	| *2* TP de 1,5h (sur 1 semaine).
|======================

[[utils]]
== Fichiers utiles

- le link:util/plantuml.bat[plantuml.bat]
- la link:util/java8/plantUmlDoclet.jar[doclet pour javadoc] (version non officielle,
mais compatible java `1.8`, si vous avez besoin de la version officielle : link:util/plantUmlDoclet.jar[doclet 1.7])
- le link:util/plantuml.jar[jar plantuml]

== Rappel sur le patron Stratégie

[[strategy]]
[NOTE]
.Design pattern : *Stratégie* (_Strategy_)
====
include::pattern/strategy.txt[]
====

TIP: N'hésitez pas à (re)lire régulièrement le {sitecours}.

== Reprise du TD

[NOTE]
=====
Les TPs sont prévus se dérouler sur {eclipse}, mais vous êtes libre
d'utiliser l'éditeur de votre choix.
=====

. Téléchargez le code de l'application `SuperCanardBof` existante link:TP1.zip[TP1.zip].
+
[TIP]
======
Attention quelques étapes sont nécessaires à l'utilisation de ces fichiers sous eclipse/Windows :

. Importer dans {eclipse} le projet (menu:File[Import... > Existing Projects into Worspace]
 et choisir `TP1.zip` que vous venez de télécharger.
. Positionner `Junit` dans le `Classpath`(btn:[Clic Droit] sur votre projet
menu:Properties[Java Build Path > Add Library] et choisir `Junit4`)
. Si Windows, dans la ligne suivante de `SuperCanardTest`, il faut remplacer
les deux points de l'option `-cp` par un point virgule :
+
[source,java]
-------
executionProgrammeATester = Runtime.getRuntime().exec("java -cp .;./bin "+programmeATester);
-------
======
. Lancez l'application elle-même pour vérifier que tout fonctionne.
. Regardez le programme de test fonctionnel `SuperCanardTest` qui vérifie de
manière automatique que tout fonctionne comme on le faisait en MPA.
. Regardez le programme de test fonctionnel `SuperCanardTest2` qui vérifie de
manière automatique que tout fonctionne, mais d'une manière plus proche des
tests unitaires.
. Implémentez rapidement le patron _Strategy_ comme préparé en TD en modifiant
le code en conséquence.
. Rejouez les tests pour vérifier que tout fonctionne toujours.

== Jeu d'aventure

=== Bases

. En utilisant le patron _Strategy_, et en utilisant l'organisation en
paquetage donnée en <<setArme,fin de TP>>), implémentez les classes et comportements du jeu d'aventure
du TD1 (section 2.7.2) et dont voici les bases :
+
.Un jeu d'aventure minimaliste
image::aventure.png[link="images/aventure.png"]

=== Améliorations

On souhaite maintenant obliger les concepteurs de tout nouveau `Personnage` à
implémenter systématiquement à l'instanciation le comportement d'arme.

. Proposez une solution à ce problème
+
TIP: il est tout à fait légal de créer un constructeur pour une classe abstraite...
+
. Implémentez cette solution en modifiant votre application
. Testez d'ajouter une nouvelle classe de `Personnage` qui n'implémente pas le comportement
et vérifiez que ça ne passe pas la compilation.

=== Utilisation du comportement dynamique

On souhaite pleinement bénéficier du changement possible de comportement
à l'exécution.

. Réalisez une application qui, à partir d'un menu, permet de créér
un personnage parmis les types possibles, et de lui affecter une arme.
. Vérifiez qu'en changeant d'arme, le comportement change.

=== _Reverse engineering_ du code

TIP: Lire la section <<reverse>> avant d'attaquer cette partie.

Le rendu de ce TP doit se faire sous la forme du diagramme de classe de votre application finale.

Pour cela utilisez les fichiers disponibles en début de ce TP et de l'une des techniques
suivantes (*`build.xml` recommandée*) :

- Utilisation de {ant} :
+
[source,ant]
----
include::util/build.xml[]
----
+
[WARNING]
====
// Merci André! Merci Louis!
. Attention, si le script ne fonctionne pas avec java `1.8`, c'est que
vous avez la version officielle de la doclet plantuml et non la version
patchée par Louis Chanouha ()
Dans ce cas-là, pour que ça fonctionne, indépendamment du jre utilisé dans le projet {Eclipse} (7 ou 8),
on a deux solutions :
* Utiliser {ant} en ligne de commande :
** Dans Windows : se mettre en java 7, le mieux est avant de démarrer {Eclipse} de la façon suivante :
menu:Démarrer[Tous les programmes > Java > Version Java par défaut] puis Sélectionner la version 7.
+
image::plantuml1.7.png[width=50%]
+
** Vérifier dans une fenêtre de commande : `java -version` => 1.7
** Travailler dans Eclipse (classes, comments, créer le build, mettre les jar, ...)
** Dans la fenêtre de commande :
*** se positionner dans le répertoire du `build.xml`
*** taper la commande : `ant`
** Ca doit être ok (refresh dans {Eclipse} si besoin)
** Dans {eclipse} :
*** Peut importe le jre utilisé pour le projet
*** Dans les paramètres de lancement du build (`Run as ...` ou `Ant Build ...`) :
**** Créer la variable `path` vers `C:\Programmes\java\jdk1.7.xxx.xxx\bin`
+
image::runas.png[width=80%]
+
WARNING: pas vers le lien windows `jdk1.7\bin` qui existe, pas `jdk1.8.xx`
+
**** Modifier dans la même fenêtre, dans l'onglet JRE, le JRE utilisé pour exécuter le build
***** Prendre Seperate jre => 7
***** Si besoin : installer la jre 7 (toujours pareil : `C:\Programmes\java\jre1.7.xx.xx`
et pas le lien windows vers jre1.7)
*** Ca doit marcher
====

- Utilisation d'un script Windows
+
.Exemple de `.BAT` qui devrait fonctionner
[source,shell]
----
set UML=TD1.uml
set TYPE='PNG'
set DOCLETPATH=
echo "Creating %UML%..."

javadoc -J-DdestinationFile=%UML% -J-DcreatePackages=false
-J-DshowPublicMethods=true -J-DshowPublicConstructors=false
-J-DshowPublicFields=true -doclet de.mallox.doclet.PlantUMLDoclet
-docletpath plantUmlDoclet.jar src/appli/*.java
src/comportements/arme/*.java src/comportements/arme/impl/*.java
src/personnages/*.java
echo "Done."

set TYPE='png'
echo "Converting %UML% to $TYPE..."
java -jar plantuml.jar -config "config.cfg" -t %TYPE% %UML%
echo "Done."
----
+
- Utilisation d'un script shell équivalent au précédent (cf. <<plantumlShell,plantuml.sh>>)
- Si vous n'avez pas le temps ou si aucune méthode ne fonctionne, obtenez votre
diagramme de classe à partir d'eclipse avec le plugin plantUML (attention, choisir
menu:Window[Show View > Other... > PlantUML > PlantUML Source]).

WARNING: Seul le fichier `TP1.uml` est à rendre (pas le `PNG`) sur le dépôt
Moodle avant vendredi 18/11 à minuit.

:numbered!:
[appendix]
[[setArme]]

== Exemple d'organisation en paquetages

Le principe est d'avoir :

- un _package_ pour les classes métiers (e.g., `Canard`,`Colvert`, etc.)
- un autre pour les comportements (1 par type de comportement en fait)
- dans chaque comportement avoir l'interface, puis un _package_ spécifique
aux implémentations (`impl`).

Ce qui donne pour l'application `SuperCanard` :

[source,shell]
-------
        ├── appli
        │   ├── Canard.java
        │   ├── CanardEnPlastique.java
        │   ├── Colvert.java
        │   ├── Leurre.java
        │   ├── Main.java
        │   └── Mandarin.java
        └── comportements
            ├── cancaner
            │   ├── ComportementCancan.java
            │   └── impl
            │       ├── CanardMuet.java
            │       ├── Cancan.java
            │       └── Coincoin.java
            └── voler
                ├── ComportementVol.java
                └── impl
                    ├── NePasVoler.java
                    └── VolerAvecDesAiles.java
-------

[appendix]
== Modèles et tests d'architecture

=== Principes de base

En utilisant la doclet pour Javadoc de {plantUML}, il est possible d'obtenir
le diagramme de classe correspondant à son architecture de manière automatique.

NOTE: Vous aurez également besoin du fichier link:util/config.cfg[config.cfg].

=== Exemple

Prenons l'exemple de l'application `SuperCanardBof`.

NOTE: Vous ne devez pas générer de modèle pour vos cabards, mais pour votre
jeux d'aventure. Ce qui suit est juste une illustration de ce que vous devez faire pour
votre application de jeu.

On peut écrire le script suivant :

.Génération automatique de diagramme PlantUML (cf. <<utils>>)
[source,shell]
---------
include::src/java/SuperCanardBof/plantuml.bat[]
---------

Ce qui permet d'obtenir automatiquement le diagramme suivant :

.Modèle de l'application `SuperCanardBof` (généré automatiquement)
image::superCanardBofGenerated.png[width=90%,link=images/superCanardBofGenerated.png]

TIP: Observez dans les sources des fichiers Java comment il est possible d'ajouter
des éléments directement dans le code à destination du plantUML généré.

L'intérêt est double :

- le modèle est par définition conforme au code
- on peut le tester :-)

Voici un exemple simple de test qui vérifie quelques points simples de
l'architecture de l'application :

.Test du modèle UML généré en Ruby (source link:src/java/SuperCanardBof/checkModel.rb[ici])
[source,ruby]
----------
include::src/java/SuperCanardBof/checkModel.rb[lines=8..200]
----------

Ce qui donne le résultat :

...............
$ ruby checkModel.rb
MiniTest::Unit::TestCase is now Minitest::Test. From checkModel.rb:12:in `<main>'
Run options: --seed 21820

# Running:

...

Finished in 0.002029s, 1478.5609 runs/s, 1478.5609 assertions/s.

3 runs, 3 assertions, 0 failures, 0 errors, 0 skips
...............

Si vous voulez vérifier que votre modèle d'architecture est bien conforme
à ce qui est demandé, vous pouvez utiliser le programme de test suivant :

.Test du patron _Strategy_ sur les `Canard` en Ruby (source link:src/java/TD1/checkModel.rb[ici])
[source,ruby]
----------
include::src/java/TD1/checkModel.rb[lines=8..200]
----------

=== Limitations

Si vous avez observé le diagramme obtenu, vous verrez qu'il n'y a pas
les associations (ni les dépendances). Plutôt que d'aller les rajouter
"à la main", vous pouvez utiliser les annotations plantUML, comme par exemple :

[source,java]
-------
/**
* @extends Controller
* @extends EmbeddedAgent
* @navassoc - - 1..* PowerManager
* @note this is a note
*/
class SetTopController implements URLStreamHandler {
  public String name;

  int authorizationLevel;
  void startUp() {}
    void shutDown() {}
      void connect() {}
      }
-------

Utilisez les annotations pour compléter vos codes Java de façon
à générer un diagramme de classe le plus complet possible.

[appendix]
== Pour aller plus loin

. Testez les limites de votre implémentation (par exemple avez-vous pensé à
  ce qui se passe si quelqu'un fait un `new Chevalier(null,null)` ?).
. Vous pouvez imaginer une application graphique :-)
. Repérez la partie de votre application principale qui fait le lien entre une arme
donnée et le comportement à affecter au personnage. Comment pourrait-on améliorer cette
"correspondance"?
. À propos de `SuperCanardTest2` :
- c'est intéressant pour les méthodes qui produisent des lignes sur la sortie standard
- ça reste du test unitaire qui se rapproche du test fonctionnel
parce que l'on réécrit le `main()` dans les fonctions de test
- les méthodes produisent des messages sur la sortie standard. Bien sûr il aurait
été préférable qu'elles retournent des `String`
+
[NOTE]
=====
Java n'est pas l'idéal pour faire du test fonctionnel.
Ce serait plus simple de faire les tests fonctionnels avec python ou ruby
car ils sont proches de l'OS et plus efficaces pour faire toute sorte de _parsing_
et de _matching_. Utiliser un autre langage
pour les tests fonctionnels illustre aussi clairement qu'il s'agit de se placer
à l'extérieur du programme testé.
=====
- Notez l'utilisation d'une
expression régulière pour éviter les conflits d'OS pour le codage de la fin de
ligne. Notez que depuis Java 8 il existe un `\R` pour ça et que
qu'il existe aussi la possibilité d'utiliser `String System.getProperty("line.separator");`
pour les versions avant Java 7, et `System.lineSeparator()` depuis Java 7.


ifndef::compact[]
== About...

****************************************************************
Document réalisé via  {asciidoctorlink} (version `{asciidoctor-version}`) de 'Dan Allen', lui même basé sur {asciidoc}.
Libre d'utilisation et géré par la 'Licence Creative Commons'.
image:88x31.png["Licence Creative
Commons",style="border-width:0",link="http://creativecommons.org/licenses/by-sa/3.0/"]
http://creativecommons.org/licenses/by-sa/3.0/[licence Creative Commons Paternité - Partage à l&#39;Identique 3.0 non transposé].
****************************************************************
endif::compact[]
