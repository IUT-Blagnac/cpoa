:moduleTitle: R3.04 Qualité
:authorDefault:  BUT/Info/S3/R3.04

:tdnum: TD5 - Patron Factory

:sourcedir: src/java/TD2

//////
ifndef::definitions[]
include::definitions.txt[]
endif::definitions[]
//////

ifndef::myasciidoconf[]
include::asciidoc.conf[]
endif::myasciidoconf[]


:numbered:
:!linkcss:
:toc:


:doctitle:  {moduleTitle} - Sujet {tdnum}
ifdef::eleve[]
:doctitle:  {moduleTitle} - Sujet {tdnum}
endif::eleve[]
ifdef::prof[]
:doctitle: {moduleTitle} - Support {tdnum}
endif::prof[]
ifdef::todoprof[]
:doctitle: {moduleTitle} - DEROULEMENT SEANCE PROF {tdnum}
endif::todoprof[]

:icons: font
:experimental:

= {doctitle}
// TESTS

// :prof:

:Author:  {authorDefault} - (Semaine 46)
:lang: fr
:incremental:

// eleve : sujet pour élèves
// prof : support prof pour séance
// todoprof : support AVEC EXPLICATIOSN DEROULEMENT pour profs

//----------- définitions --------------
:sitecours: http://webetud.iut-blagnac.fr/[Support de Cours]
:pre: PreReq
:objtd: ObjTD
:duree: Durée
:depot: À rendre
:lien: Lien
:img: img
:principe: Principe de conception
:allerPlusLoin: Pour aller plus loin
:about: À propos

//-------------------- Warning si correction -----------
ifdef::prof[]
[CAUTION,solution]
.Version corrigée image:icons/solution.png[]
=====
Cette version comporte des indications pour les
réponses aux exercices.
=====
endif::prof[]

//-------------------- Cartouche d'en-tête -----------
[align="left",cols="1,10a",width="100%"]
|======================
| {pre}		|
1. Je sais programmer en {java}.
2. J'ai conscience qu'il faut réfléchir avant de se lancer dans le codage.
3. Je maîtrise les concepts objet de base (héritage, polymorphisme, ...).
4. J'ai compris ce qu'est un patron et j'ai grand soif d'en apprendre d'autres que
_Strategy_ et Singleton
| {objtd}	| Aborder le patron *fabrique*.
| {duree}	| *1* TD de 1,5h.
|======================


ifndef::compact[]

== Rappel du cours

TIP: N'hésitez pas à (re)lire régulièrement le {sitecours}.

endif::compact[]

== La pizzeria O'Reilly

Vous êtes embauché dans une pizzeria pour faire ... de l'informatique !

Le stagiaire de l'an dernier qui avait travaillé sur le code est parti avec
la caisse (de Chianti). Vous n'avez à votre disposition que :

. Le code de départ suivant :
+
.Code de `Pizzeria.java`
[source,java]
------
include::src/java/JMIsPizzas/src/Pizzeria3.java[]
------
+
. L'ébauche de diagramme de classe des pizzas suivant :
+
image::Pizzas-2022.png[width=60%,scaledwidth=70%,align=center]
+
. Le bout de code de test suivant :
+
[source,java]
------
Pizzeria boutiqueBrest = new Pizzeria();
boutiqueBrest.commanderPizza("fromage");
...
Pizzeria boutiqueStrasbourg = new Pizzeria();
boutiqueStrasbourg.commanderPizza("grecque");
------

//----------------------------- Question ------------------
.*QUESTION*
[WARNING]
====
. Identifiez ce qui varie dans ce code (si la pression du marché fait
	ajouter des pizzas à la carte ou si une pizza n'a plus de succès et doit
	disparaître, etc.).
. Isolez dans une classe `SimpleFabriqueDePizzas` ce code.
. Réalisez le diagramme de classe obtenu.
. Quel est l’avantage de procéder ainsi ? Ne transfère-t'on pas
simplement le problème à un autre objet ?
====

TIP: Bien sûr vous héritez de cet horrible "if then else" et dans
votre implémentation en TP vous remplacerez ce code avantageusement
par un "switch case" et utiliserez une `enum` comme link:{urlcours}#enum[vu en cours].

//----------------------------------------------------- Correction -------------------------
ifdef::prof[]
.Solution image:icons/solution.png[]
[CAUTION]
========
.	La fabrication de la pizza elle-même suivant le type : la suite de `if (type.equals("..."))`
.	Code de SimpleFabriqueDePizzas
+
[source,java]
------
include::src/java/JMIsPizzas/src/SimpleFabriqueDePizzas.java[]
------
 
+
NOTE: Faire remarquer que la pizza n'est plus la propriété de la pizzeria, mais
de la fabrique !
+
Dans `Pizzeria`, le `if` à remplacer par un `pizza = fabrique.creerPizza(type);`
+
et on ajoute le code suivant dans la classe Pizzeria :
+
[source,java]
------
public class Pizzeria {

	private SimpleFabriqueDePizzas fabrique;

	public Pizzeria(SimpleFabriqueDePizzas fabrique) {
		this.fabrique = fabrique;
	}

	public Pizza commanderPizza(String type) {

		Pizza pizza;
		
		pizza = fabrique.creerPizza(type);

		pizza.preparer();	pizza.cuire();	pizza.couper();	pizza.emballer();

		return pizza;
	}
------
+
. Diagramme de classe :
+
image::Pizzeria2.png[width=90%,scaledwidth=90%]
+
. En encapsulant la création des pizzas dans une seule classe, nous n’avons plus qu’un seul endroit auquel apporter
des modifications quand l’implémentation change.
========
:icons: font
endif::prof[]

== On y est presque...

Nous sommes arrivés à une situation propre, qui s'apparente
à un patron de conception. Mais avant d'en arriver à la définition
du patron lui-même, nous allons améliorer un peu les choses.

=== Succès des pizzerias O'Reilly : les franchises

Plusieurs villes veulent ouvrir des pizzerias comme la vôtre.
Votre patron, très content de vos programmes souhaite imposer à toutes
les futures pizzerias d'utiliser vos codes.

Le problème : les pizzas au fromage de Strasbourg sont différentes
des pizzas aux fromages de Corse !

//----------------------------- Question ------------------
.*QUESTION*
[WARNING]
====
Proposez une solution où `SimpleFabriqueDePizzas` serait une
classe abstraite.
====
//----------------------------------------------------- Correction -------------------------
ifdef::prof[]
.Solution image:icons/solution.png[]
[CAUTION]
========
Simplement ajouter abstract, créer plusieurs sous-classes et avoir
une utilisation du style :

[source,java]
------
SimpleFabriqueDePizzas fabriqueBrest = new FabriqueDePizzasBrest();
Pizzeria boutiqueBrest = new Pizzeria(fabriqueBrest);
boutiqueBrest.commander("Végétarienne");
...
SimpleFabriqueDePizzas fabriqueStrasbourg = new FabriqueDePizzasStrasbourg();
Pizzeria boutiqueStrasbourg = new Pizzeria(fabriqueStrasbourg);
boutiqueStrasbourg.commander("Végétarienne");
------

image::PizzeriaAbstraiteDepart.png[width=80%,scaledwidth=90%]

========
endif::prof[]

=== La dérive : chacun travaille comme il l'entend !

Les pizzerias utilisent bien vos fabriques mais ont changé
leurs procédures : certaines ne coupent pas les pizzas, changent les
temps de cuissons, ne les emballent pas, et les pizzerias O'Reilly perdent leur
identité. Il nous faut donc *restructurer* les pizzerias.

Un consultant italien payé fort cher d'ailleurs (heureusement en pizzas !)
propose de revenir à la structure suivante :

[source,java]
------
public abstract class Pizzeria {
	public final Pizza commanderPizza(String type) {
		Pizza pizza;

		pizza = creerPizza(type);
		pizza.preparer();
		pizza.cuire();
		pizza.couper();
		pizza.emballer();

		return pizza;
	}

	....... Pizza creerPizza(String type);
}
------

//----------------------------- Question ------------------
.*QUESTION*
[WARNING]
====
Quelles sont les différences avec notre conception actuelle?
====
//----------------------------------------------------- Correction -------------------------
ifdef::prof[]
.Solution image:icons/solution.png[]
[CAUTION]
========

- Pizzeria est maintenant abstraite (vous allez voir pourquoi ci-dessous).
- Maintenant, `creerPizza()` est de nouveau un appel à une méthode de Pizzeria
et non à un objet fabrique.
- Et nous avons transféré la fonctionnalité de notre objet fabrique à cette méthode.
- Notre "méthode de fabrication de pizza" `commanderPizza(String type)` est maintenant final dans `Pizzeria` => les sous classes ne peuvent pas la redéfinir ! Toutes les pizzerias prépareront, cuiront, couperont, emballeront les pizzas de la même manière. Seule la méthode `creerPizza()` changera ...
========
endif::prof[]

=== Laisser les sous-classes décider

//----------------------------- Question ------------------
.*QUESTION*
[WARNING]
====
Dans le schéma suivant, placez les méthodes au bon endroit de
façon à ce que les procédures soient respectées tout en ayant des pizzas
à variantes "régionales".

image::Pizzeria3.png[width=60%,scaledwidth=60%]
====
//----------------------------------------------------- Correction -------------------------
ifdef::prof[]
.Solution image:icons/solution.png[]
[CAUTION]
========

image::Pizzeria3-sol.svg[width=60%]

Chaque sous-classe redéfinit la méthode `creerPizza()`,
tandis que toutes les sous-classes utilisent la méthode `commanderPizza()`
définie dans `Pizzeria`.

Voici un exemple de Pizzeria concrète :

[source,java]
------
public class PizzeriaBrest extends Pizzeria {
	... Pizza creerPizza(String item) {
	if (choix.equals("fromage")) {
			return new PizzaFromageStyleBrest();
		} else if (choix.equals("vegetarienne")) {
			return new PizzaVegetarienneStyleBrest();
		} else if (choix.equals("fruitsDeMer")) {
			return new PizzaFruitsDeMerStyleBrest();
		} else if (choix.equals("poivrons")) {
			return new PizzaPoivronsStyleBrest();
		} else {
			return null;
		}
	}
}
------

========
endif::prof[]

=== Déclarer une méthode de fabrique

Rien qu'en apportant une ou deux transformations à `Pizzeria`,
nous sommes passés d'un objet gérant l'instanciation de nos classes concrètes
à un ensemble de sous-classes qui assument maintenant cette responsabilité.

//----------------------------- Question ------------------
.*QUESTION*
[WARNING]
====
Quelle est la déclaration exacte de la méthode `creerPizza()`
de la classe `Pizzeria` ?
====
//----------------------------------------------------- Correction -------------------------
ifdef::prof[]
.Solution image:icons/solution.png[]
[CAUTION]
========

[source,java]
------
protected abstract Pizza creerPizza(String type);
------

- `protected abstract` : Comme une méthode de fabrication est abstraite,
on compte sur les sous-classes pour gérer la création des objets.
- `protected` : inutile d'exposer la méthode à l'extérieur; aux sous-classes oui pour la redéfinir.
- `Pizza` : Une méthode de fabrication retourne un Produit qu'on utilise généralement
dans les méthodes définies dans la superclasse.
- `creerPizza`: Une méthode de fabrique isole le client (le code de la superclasse,
	tel `commanderPizza()` : elle lui évite de devoir connaître la sorte de
	Produit concret qui est réellement créée.
========
endif::prof[]

=== Récapitulons

//----------------------------- Question ------------------
.*QUESTION*
[WARNING]
====
Donnez le diagramme de séquence d'une "commande de pizza au fromage
de type Strasbourg".
====
//----------------------------------------------------- Correction -------------------------
ifdef::prof[]
.Solution image:icons/solution.png[]
[CAUTION]
========
image::Pizzeria-sec-2022.png[width=100%,scaledwidth=100%]
========
endif::prof[]

NOTE: Vous implémenterez les classes manquantes en TP.

== Le patron Fabrique (simple)

Nous y sommes, vous venez de décortiquer le patron Fabrique Simple

[NOTE]
.Design pattern : *Fabrique (simple)*
====
include::pattern/fabrique.txt[]
====

ifndef::compact[]

ifndef::pdf[]

.Quelques exemples de description du patron Fabrique
image::google-fabrique.png[link="images/google-fabrique.png",width=100%,scaledwidth=100%]

endif::pdf[]

endif::compact[]


== Pour aller plus loin

=== Et les pizzas dans tout ça !?

//----------------------------- Question ------------------
.*QUESTION*
[WARNING]
====
Proposez un diagramme de classe UML pour les pizzas (classes, attributs et méthodes).
====
//----------------------------------------------------- Correction -------------------------
ifdef::prof[]
.Solution image:icons/solution.png[]
[CAUTION]
========
image::Pizzas-dc-2022.png[width=100%,scaledwidth=100%]

Exemple de code pour `Pizza` :

[source,java]
---------
public abstract class Pizza {
	protected String nom;
	protected String pate;
	protected String sauce;
	protected List <Ingredient> garnitures;

	protected Pizza (String _n, String _p, String _s, List<Ingredients> _l) {
		nom = _n;
		pate = _p;
		sauce = _s;
		garnitures = new ArrayList<>();
		garnitures.addAll(_l);
	}
	public void preparer() {
		System.out.println("Préparation de " + nom);
		System.out.println("Étalage de la pâte...");
		System.out.println("Ajout de la sauce...");
		System.out.println("Ajout des garnitures: ");
		for (int i = 0; i < garnitures.size(); i++) {
			System.out.println(" " + garnitures.get(i));
		}
	}
	public void cuire() {
		System.out.println("Cuisson 25 minutes à 180°");
	}
	public void couper() {
		System.out.println("Découpage en parts triangulaires");
	}
	public void emballer() {
		System.out.println("Emballage dans une boîte officielle");
	}
	public String getNom() {
		return nom;
	}
}
---------

========
endif::prof[]

=== Et sans patron, ça donne quoi ?

Un stagiaire de 2013 (les patrons n'étaient pas au programme du PPN !)
a réalisé le programme suivant :

[source,java]
------
include::src/java/JMIsPizzas/src/PizzeriaDependante.java[]
------

//----------------------------- Question ------------------
.*QUESTION*
[WARNING]
====
. Faites le compte du nombre de classes concrètes dont cette classe dépend.
. Et si vous ajoutez des pizzas de style Marseille à cette Pizzeria ?
. Quel est le principe SOLID non respecté par cette classe ?
====
//----------------------------------------------------- Correction -------------------------
ifdef::prof[]
.Solution image:icons/solution.png[]
[CAUTION]
========
. 8
. 12
+
TIP: À comparer aux 2 (fabrique et pizza) des Pizzérias avec Fabrique
+
.	OCP : Open/Close Principle : suite de `if` qu'il faut modifier à chaque changement. Elle n'est pas fermée à la modification.

========
endif::prof[]

=== Problème du main de test du jeu d'aventure

Vous avez sûrement dans votre `main` de l'application de jeu d'aventure
une partie du code ressamblant à ceci :

.Adaptation des comportements à la situation
[source,java]
-----
if (choix.equals("Epee")) {
	perso.setArme(new ComportementEpee());
}
else if (choix.equals("Arc")) {
	perso.setArme(new ComportementArc());
	else if ...
	...
}
-----

Ce code est peu adaptatif et va souffrir des évolutions, par exemple :

- changement de la liste des armes possibles
- rajouter des `if then else` à chaque nouvelle arme
- suppression de certaines armes
- ...

//----------------------------- Question ------------------
.*QUESTION*
[WARNING]
====
. Isoler ce code dans une classe `SimpleFabriqueArme` qui possédera
une méthode `creerComportementArme(String type)` qui retourne le comportement
adapté en fonction du paramètre reçu.
. Donnez le diagramme de classe {UML} de la nouvelle organisation.
. Quelles différences a-t-on avec le patron Fabrique ? Donner quelques exemples d’extension du jeu d'aventure qui correspondraient à l'usage d'une Fabrique.
. Donnez le diagramme de séquence du main. Par exemple avec le code de test suivant :
+
[source,java]
------
Chevalier perso = new Chevalier("JMB");

SimpleFabriqueArme fabrique = new SimpleFabriqueArme();
ComportementArme c = fabrique.creerComportementArme("Epee");

perso.setArme(c);
perso.frapper();
------
====
//----------------------------------------------------- Correction -------------------------
ifdef::prof[]
.Solution image:icons/solution.png[]
[CAUTION]
====
. Implémentation
+
.Extrait de FabriqueArme.java
[source,java]
-----
include::src/java/TD3/src/simuaventure/comportements/arme/impl/SimpleFabriqueArme.java[lines=12..25]
-----
+
. Diagramme de classe de la fabrique de comportements d'armes
+
image::fabriqueArme.png[width=100%,scaledwidth=100%]
+
. Le créateur et le créateur concrêt sont dans une unique classe (SimpleFabriqueArme) car on a une seule fabrique unique pour le moment. On peut imaginer deux modes de jeu, avec des armes médiévales (épée en métal) ou modernes (épée sabre laser) qui seront traités dans deux fabriques concrètes différentes "FabriqueArmeMedievales" et "FabriqueArmeModernes".
. Diagramme de séquence du `main`.

image::fabriqueArme-seq.svg[width=100%,scaledwidth=100%]

====
endif::prof[]
//----------------------------------------------------- fin Correction -------------------------

///////
ifndef::backend-pdf[]

ifndef::compact[]
== About...

****************************************************************
Document réalisé via  {asciidoctorlink} (version `{asciidoctor-version}`) de 'Dan Allen', lui même basé sur {asciidoc}.
Libre d'utilisation et géré par la 'Licence Creative Commons'.
image:88x31.png["Licence Creative
Commons",style="border-width:0",link="http://creativecommons.org/licenses/by-sa/3.0/"]
http://creativecommons.org/licenses/by-sa/3.0/[licence Creative Commons Paternité - Partage à l&#39;Identique 3.0 non transposé].
****************************************************************
endif::compact[]

endif::backend-pdf[]
///////