:moduleTitle: R3.04 Qualité
:authorDefault:  BUT/Info/S3/R3.04

:tdnum: TP3 - Patron Stratégie

:sourcedir: src/java/TD1

include::definitions.txt[]

// ATTENTION !
// Enlevé linkcss car car génére les css à côté du fichier html
// :linkcss:

// L'enlève au besoin (! undefines the variable)
:!linkcss:

:doctitle:  {moduleTitle} - Sujet {tdnum}
ifdef::eleve[]
:doctitle:  {moduleTitle} - Sujet {tdnum}
endif::eleve[]
ifdef::prof[]
:doctitle: {moduleTitle} - Support {tdnum}
endif::prof[]
ifdef::todoprof[]
:doctitle: {moduleTitle} - DEROULEMENT SEANCE PROF {tdnum}
endif::todoprof[]




:Author:  {authorDefault}
:lang: fr
:slideshowlocation: Your computer
:copyright: {date={localdate}}, {slideshowlocation} *** {author} *** Powered by AsciiDoc and W3C Slidy &#169; 
:toc-title: Table des Matières
:toc: left
:incremental!:
:source-highlighter: pygments
:numbered:
:iconsdir: icons/
:icons: true
:imagesdir: images


:eclipse: http://www.eclipse.org/[eclipse]
:eclipseversion: 2022
:eclipsedownload: https://www.eclipse.org/downloads/packages/release/2019-12[Eclipse Oxygen]

//----------- définitions --------------
:sitecours: http://webetud.iut-blagnac.fr/[Support de Cours]
:pre: PreReq
:objtd: ObjTP
:duree: Durée
:depot: À rendre
:lien: Lien
:img: img


= {doctitle}


//-------------------- Warning si correction -----------
ifdef::prof[]
[CAUTION]
.Version corrigée
=====
Cette version comporte des indications pour les
réponses aux exercices.
=====
endif::prof[]

//-------------------- Cartouche d'en-tête -----------
[[cartouche]]
[align="left",cols="1,10a",width="90%"]
|======================
| {pre}		|
. Je sais programmer en {java}.
. J'ai conscience qu'il faut réfléchir avant de se lancer dans le codage.
. Je maîtrise les concepts objet de base (héritage, polymorphisme, ...).
. J'ai réalisé le TD `SuperCanard` et donc connait le patron _Strategy_!
| {objtd}	| Comprendre ce qu'est une *conception* et implémenter mon premier patron.
| {duree}	| *2* TP de 1,5h.
| {depot} | *Les répertoires src des codes produits (3 projets a priori) + fichiers .uml (ou .txt) des codes plantuml produits durant le TPs*
|======================

[[utils]]
== Fichiers utiles

Récupérer le fichier zip depuis le serveur.

Il contient :

- le code source de démarrage TP3_SuperCanardBof.zip
- le plantuml.bat nécessaire plus tard
- la doclet pour javadoc (version non officielle,
mais compatible java `1.8`, si vous avez besoin de la version officielle : link:util/plantUmlDoclet.jar[doclet 1.7])
- le jar plantuml
- divers fichiers utilisés dans le TP

//////
- le link:util/plantuml.bat[plantuml.bat] nécessaire plus tard
- la link:util/java8/plantUmlDoclet.jar[doclet pour javadoc] (version non officielle,
mais compatible java `1.8`, si vous avez besoin de la version officielle : link:util/plantUmlDoclet.jar[doclet 1.7])
- le link:util/plantuml.jar[jar plantuml]
//////

[[patstrat]] 
== Rappel sur le patron Stratégie

[[strategy]]
[NOTE]
.Design pattern : *Stratégie* (_Strategy_)
====
image::strategyAvecAttribut.svg[]
====

TIP: N'hésitez pas à (re)lire régulièrement le {sitecours}.

== Stratégie dans `java.util` : méthode `sort()`

=== La situation : comprendre

. Etudiez et comprenez la documentation de la méthode `sort()` de la classe `List` : link:https://docs.oracle.com/javase/8/docs/api/java/util/List.html[Documentation de `List`] et link:https://docs.oracle.com/javase/8/docs/api/java/util/List.html#sort-java.util.Comparator-[Documentation de `sort()`]

. Cette méthode permet de trier la liste à laquelle elle est appliquée. Pour comprendre `sort(Comparator<? super E> c)` :
..  Rappelez-vous les algorithmes de tris : à un moment donné il faut comparer deux éléments pour trouver le plus grand/plus petit des deux.
..  Ainsi `sort()` applique un algorithme de tri (double parcours, ...) et utilise son paramètre `Comparator c` en paramètre pour comparer deux éléments et décider de les permuter (ou pas).
..  Le paramètre `Comparator c` est lui chargé de comparer deux éléments de la liste lors du tri.
. Etudiez et comprenez le documentation de l'interface link:https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html[`Comparator`] : en particulier la méthode `int compare(T o1, T o2)`. 
..  Remarquez que la documentation de `sort()` indique qu'elle utilise cette méthode.
..  C'est cette méthode qu'il nous faudra implémenter.
+
[NOTE]
.Remarque
====
Ne prenez pas en compte les autres méthodes de `Comparator` (à regarder plus tard si vous le souhaitez).
====


=== Mise en oeuvre

Nous allons faire des tris de listes de chaînes de caractères (`List<String>`) en utilisant `sort()`. 

`Comparator` étant une interface, il va nous falloir implémenter `Comparator<String>`...

==== Première version simple

Puisqu'il nous faut implémenter une interface : créons une classe !

. Pour commencer, *reprenez* dans un projet {eclipse} le code suivant. Il vous faudra compléter la méthode `test()` pour trier la variable `li`.
+
[source,java]
.Code à reprendre
-------
import java.util.Arrays;
import java.util.List;

public class TestSort {
	public static void main(String[] args) {	
		TestSort ts = new TestSort();
		ts.test();
	}

	private void test() {
		List<String> li = Arrays.asList("aaa", "b", "AAA", "eee", "ffff", "g", "h", "i", "FF", "j", "k", "K");
	
		// Faire ici li.sort(...) comme demandé
		
		printList(li);
	}
	private void printList (List<String> l) {
		for (String s : l) {
			System.out.println(s);
		}
	}
}
-------

. Créez dans le projet une classe (`ComparaisonStringSurLongueur`) qui implémente `Comparator<String>`
. Ecrivez le code de la méthode `int compare(String s1, String s2)` de telle sorte qu'elle compare ses deux paramètres sur leur longueur de chaine. La méthode renverra :
..  -1 si s1 considérée plus petit que s2 (sur la longueur donc), 
..  0 si s1 est considérée égale à s2,
..  +1 si s1 est considérée supérieure à s2.
. Utiliser un objet de cette classe pour trier la liste `li` dans le code fourni en utilisant `sort()`.

==== Amélioration : classe interne

La classe créée précédemment est déclarée dans le package mais a priori, seule la classe `TestSort` va l'utiliser. Ainsi, on expose une classe assez inutile.

Pour résoudre cela, java permet de déclarer une classe `interne` à une autre classe. Pour plus d'infos link:https://fr.wikibooks.org/wiki/Programmation_Java/Classes_internes[voir ce site sur classes internes].

.   *Reprenez* la classe `TestSort` et déclarez une classe interne `ComparaisonStringMajMin` qui implémente `Comparator<String>` et fera une comparaison alphabétique des chaînes sans différencier la casse (majuscules et minuscules). 
..  Voir du côté de `String : toUppercase()` et `String : compareTo()`.
..  Vous pouvez même déclarer la classe private (elle ne sera pas utilisée ailleurs).
.   Utilisez cette classe pour, à la suite du test précédent, trier une deuxième fois `li` par ordre alphabétique sans différencier la casse et réafficher `li`.

==== Amélioration + : Classe interne anonyme

Au final, la classe décrite précédemment n'est utilisée qu'une seule fois car un seul new dans le code. De plus, elle est private, il y a peu de chances qu'elle soit utilisée ailleurs dans le code.

Java propose de simplifier cette situation : déclarer la classe (code de la classe) lors du new lui-même ! Pour plus d'infos link:https://fr.wikibooks.org/wiki/Programmation_Java/Classes_internes[voir ce site sur classes anonymes].

Dans notre cas, la syntaxe de déclaration de la classe anonyme sera du type :
[source, java]
----
new Comparator<String> () {
			@Override
			public int compare(String s1, String s2) {
				...
			}		
		}
----

[NOTE]
====
Vous pourriez avoir l'impression de faire un new d'une interface ce qui est interdit en java : *en fait vous faites un new d'une "classe anonyme"* (sans nom) dont le code est donné et implémente l'interface "sur le moment avant le new" (le `implements` est omis). La classe serait :
[source, java]
----
Comparator<String> {
  @Override
  public int compare(String s1, String s2) {
    ...
  }
}
----
====

. *Reprenez* le code pour trier et afficher une troisième fois la liste par ordre alphabétique classique de `String` en utilisant une classe interne anonyme (le new et la classe anonyme viendront directement en paramètre de `sort()`).

=== Synthèse

. *Question* : En vous référant au patron stratégie repris en <<patstrat>>, dans le cadre de la méthode `sort()` de l'exercice précédent :
..  Qui joue le rôle de la classe `Contexte` ?
..  Quelle est la méthode `contexte` ?
..  Qui joue le rôle de la classe `Stratégie` ?
..  Quelle est la méthode `algorithme()` ?


== Reprise du TD

[NOTE]
=====
Les TPs sont prévus se dérouler sur {eclipse}.
Les manipulations pour la rétro ingénierie (fin du dujet) ne seront expliqués que sur {eclipse}.
Néanmoins, vous êtes libre d'utiliser l'éditeur de votre choix en y adaptant les éléments demandés.
=====

. Récupérez le code de l'application `SuperCanardBof` existante (cf. <<utils>>).
+
[TIP]
======
Attention quelques étapes sont nécessaires à l'utilisation de ces fichiers sous eclipse/Windows :

. Importer dans {eclipse} le projet (menu:File[Import... > Existing Projects into Worspace]
 et choisir `TP3.zip` que vous avez de télécharger.
. Positionner `Junit` si besoin dans le `Classpath`(btn:[Clic Droit] sur votre projet
menu:Properties[Java Build Path > Add Library] et choisir `Junit4`)
. Si Windows, dans la ligne suivante de `SuperCanardTest`, il faut remplacer
les deux points de l'option `-cp` par un point virgule :
+
[source,java]
-------
executionProgrammeATester = Runtime.getRuntime().exec("java -cp .;./bin "+programmeATester);
-------
======
. Lancez l'application elle-même pour vérifier que tout fonctionne.
. Regardez le programme de test fonctionnel `SuperCanardTest` qui vérifie de
manière automatique que tout fonctionne.
. Regardez le programme de test fonctionnel `SuperCanardTest2` qui vérifie de
manière automatique que tout fonctionne, mais d'une manière plus proche des
tests unitaires.
. *Implémentez rapidement le patron _Strategy_ comme préparé en TD* en modifiant
le code en conséquence.
. Rejouez les tests pour vérifier que tout fonctionne toujours.

== Jeu d'aventure

=== Bases

. En utilisant le patron _Strategy_, et en utilisant l'organisation en
paquetage donnée en <<setArme,fin de TP>>), implémentez les classes et comportements du jeu d'aventure
du TD1 (section 2.7.2) et dont voici les bases :
+
.Un jeu d'aventure minimaliste
image::aventure.png[link="images/aventure.png"]

=== Améliorations

On souhaite maintenant obliger les concepteurs de tout nouveau `Personnage` à
implémenter systématiquement à l'instanciation le comportement d'arme.

. Proposez une solution à ce problème
+
TIP: il est tout à fait légal de créer un constructeur pour une classe abstraite...
+
. Implémentez cette solution en modifiant votre application
. Testez d'ajouter une nouvelle classe de `Personnage` qui n'implémente pas le comportement
et vérifiez que ça ne passe pas la compilation.

=== Utilisation du comportement dynamique

On souhaite pleinement bénéficier du changement possible de comportement
à l'exécution.

. Réalisez une application qui, à partir d'un menu, permet de créér
un personnage parmis les types possibles, et de lui affecter une arme.
. Vérifiez qu'en changeant d'arme, le comportement change.

=== _Reverse engineering_ du code

TIP: Lire la section <<reverse>> avant d'attaquer cette partie.

Le rendu de ce TP comprend le diagramme de classe de votre application finale.

Nous allons utiliser un porcessus en 2 phases : générer un fichier en code plantuml (javadoc avec une doclet adaptée) puis utiliser planuml pour générer une sortie png)

Pour cela utilisez les fichiers disponibles en début de ce TP et de l'une des techniques
suivantes (*`build.xml` recommandée*) :

- Utilisation de {ant} (`build.xml`):
+
[source,ant]
----
<project default="main">
<target name="main">
<javadoc doclet="de.mallox.doclet.PlantUMLDoclet"
   docletpath="./plantUmlDoclet.jar"
   access="private"
   additionalparam=
   "-encoding utf-8 -J-DdestinationFile=uml.txt -J-DcreatePackages=false -J-DshowPublicMethods=true -J-DshowPublicConstructors=false -J-DshowPublicFields=true"
	executable="C:/SOFTS/Java/jdk1.8.0_201/bin/javadoc"
	>
  <packageset dir="./src">
   <include name="**"/>
  </packageset>
</javadoc>

<java jar="plantuml.jar" fork="true" maxmemory="128m">
 <arg value="uml.txt"/>
</java>
</target>
</project>
----
+
----
Dans Eclipse : bouton droit sur build.xml > Run As > Ant Build.

Rafraichissez le projet pour voir les fichiers produits (txt/uml et png).

Si besoin metez le projet en "JDK Compliance" 1.8 (si ca ne marchait pas en version courante).
----

/////

[WARNING]
====
// Merci André! Merci Louis!
. Attention, si le script ne fonctionne pas avec java `1.8`, c'est que
vous avez la version officielle de la doclet plantuml et non la version
patchée par Louis Chanouha ()
Dans ce cas-là, pour que ça fonctionne, indépendamment du jre utilisé dans le projet {Eclipse} (7 ou 8),
on a deux solutions :
* Utiliser {ant} en ligne de commande :
** Dans Windows : se mettre en java 7, le mieux est avant de démarrer {Eclipse} de la façon suivante :
menu:Démarrer[Tous les programmes > Java > Version Java par défaut] puis Sélectionner la version 7.
+
image::plantuml1.7.png[width=50%]
+
** Vérifier dans une fenêtre de commande : `java -version` => 1.7
** Travailler dans Eclipse (classes, comments, créer le build, mettre les jar, ...)
** Dans la fenêtre de commande :
*** se positionner dans le répertoire du `build.xml`
*** taper la commande : `ant`
** Ca doit être ok (refresh dans {Eclipse} si besoin)
** Dans {eclipse} :
*** Peut importe le jre utilisé pour le projet
*** Dans les paramètres de lancement du build (`Run as ...` ou `Ant Build ...`) :
**** Créer la variable `path` vers `C:\Programmes\java\jdk1.7.xxx.xxx\bin`
+
image::runas.png[width=80%]
+
WARNING: pas vers le lien windows `jdk1.7\bin` qui existe, pas `jdk1.8.xx`
+
**** Modifier dans la même fenêtre, dans l'onglet JRE, le JRE utilisé pour exécuter le build
***** Prendre Seperate jre => 7
***** Si besoin : installer la jre 7 (toujours pareil : `C:\Programmes\java\jre1.7.xx.xx`
et pas le lien windows vers jre1.7)
*** Ca doit marcher
====
/////

- Utilisation d'un script Windows
+
.Exemple de `.BAT` qui devrait fonctionner - IL FAUDRA AJUSTER LES CHEMINS DE REPERTOIRE
[source,shell]
----
set UML=TP3.txt
set TYPE='PNG'
set DOCLETPATH=C:\TMP\WSPCE_2020_06_IUT_2022_2023\WspcesTPS_DEV_R3-04_22_23\Wspce_TP_R3\TP3_SuperCanardBof\SuperCanardBof
echo "Creating %UML%..."
C:\SOFTS\Java\jdk1.8.0_201\bin\javadoc -J-DdestinationFile=%UML% -J-DcreatePackages=false -J-DshowPublicMethods=true -J-DshowPublicConstructors=false -J-DshowPublicFields=true -doclet de.mallox.doclet.PlantUMLDoclet -docletpath plantUmlDoclet.jar src/test/*.java 

echo "Done."

set TYPE='png'
echo "Converting %UML% to $TYPE..."
java -cp . -jar  plantuml.jar -config ".\config.cfg" -t %TYPE% %UML%
echo "Done."
----
+
----
Dans l'explorateur de fichiers : allez dans le projet eclipse, lancez une fenêtre de commande sur ce répertoire, lancez plantuml.bat.
----
+
- Utilisation d'un script shell équivalent au précédent (cf. <<plantumlShell,plantuml.sh>>)
- Utilisation de la nouvelle doclet : https://github.com/gboersma/uml-java-doclet
- Si vous n'avez pas le temps ou si aucune méthode ne fonctionne, obtenez votre
diagramme de classe à partir d'eclipse avec le plugin plantUML (attention, choisir
menu:Window[Show View > Other... > PlantUML > PlantUML Source]).

WARNING: Le fichier `TP3.uml` est à rendre (pas le `PNG`) sur le dépôt
Moodle


=== Pour aller plus loin

Voir la section <<plusloin>> et essayez d'expérimenter quelques points.


[appendix]
[[setArme]]

== Exemple d'organisation en paquetages

Le principe est d'avoir :

- un _package_ pour les classes métiers (e.g., `Canard`,`Colvert`, etc.)
- un autre pour les comportements (1 par type de comportement en fait)
- dans chaque comportement avoir l'interface, puis un _package_ spécifique
aux implémentations (`impl`).

Ce qui donne pour l'application `SuperCanard` :

[source,shell]
-------
        ├── appli
        │   ├── Canard.java
        │   ├── CanardEnPlastique.java
        │   ├── Colvert.java
        │   ├── Leurre.java
        │   ├── Main.java
        │   └── Mandarin.java
        └── comportements
            ├── cancaner
            │   ├── ComportementCancan.java
            │   └── impl
            │       ├── CanardMuet.java
            │       ├── Cancan.java
            │       └── Coincoin.java
            └── voler
                ├── ComportementVol.java
                └── impl
                    ├── NePasVoler.java
                    └── VolerAvecDesAiles.java
-------

[WARNING]
====
 Pour avoir une vue hiérarchique des packages dans eclipse, cf. https://stackoverflow.com/questions/3915961/how-to-view-hierarchical-package-structure-in-eclipse-package-explorer

image::packagesHierarchy.png[width=50%]
====

[[reverse]]
[appendix]
== Modèles et tests d'architecture

=== Principes de base

En utilisant la doclet pour Javadoc de {plantUML}, il est possible d'obtenir
le diagramme de classe correspondant à son architecture de manière automatique.

NOTE: Vous aurez également besoin du fichier *config.cfg* livré initialement.

=== Exemple

Prenons l'exemple de l'application `SuperCanardBof`.

NOTE: Vous ne devez pas générer de modèle pour vos canards, mais pour votre
jeux d'aventure. Ce qui suit est juste une illustration de ce que vous devez faire pour
votre application de jeu.

On peut écrire le script suivant (à adapter sur les chemins) :

.Génération automatique de diagramme PlantUML (cf. <<utils>>) - IL FAUDRA AJUSTER LES CHEMINS DE REPERTOIRE
[source,shell]
---------
set UML=TP3.txt
set TYPE='PNG'
set DOCLETPATH=C:\TMP\WSPCE_2020_06_IUT_2022_2023\WspcesTPS_DEV_R3-04_22_23\Wspce_TP_R3\TP3_SuperCanardBof\SuperCanardBof
echo "Creating %UML%..."
C:\SOFTS\Java\jdk1.8.0_201\bin\javadoc -J-DdestinationFile=%UML% -J-DcreatePackages=false -J-DshowPublicMethods=true -J-DshowPublicConstructors=false -J-DshowPublicFields=true -doclet de.mallox.doclet.PlantUMLDoclet -docletpath plantUmlDoclet.jar src/test/*.java 

echo "Done."

set TYPE='png'
echo "Converting %UML% to $TYPE..."
java -cp . -jar  plantuml.jar -config ".\config.cfg" -t %TYPE% %UML%
echo "Done."
---------

Ce qui permet d'obtenir automatiquement le diagramme suivant :

.Modèle de l'application `SuperCanardBof` (généré automatiquement)
image::superCanardBofGenerated.png[width=90%,link=images/superCanardBofGenerated.png]

TIP: Observez dans les sources des fichiers Java comment il est possible d'ajouter
des éléments directement dans le code à destination du plantUML généré.

L'intérêt est double :

- le modèle est par définition conforme au code
- on peut le tester :-)

Voici un exemple simple de test qui vérifie quelques points simples de
l'architecture de l'application :

.Test du modèle UML généré en Ruby ((cf. <<utils>>)
[source,ruby]
----------
include::src/java/SuperCanardBof/checkModel.rb[lines=8..200]
----------

Ce qui donne le résultat :

...............
$ ruby checkModel.rb
MiniTest::Unit::TestCase is now Minitest::Test. From checkModel.rb:12:in `<main>'
Run options: --seed 21820

# Running:

...

Finished in 0.002029s, 1478.5609 runs/s, 1478.5609 assertions/s.

3 runs, 3 assertions, 0 failures, 0 errors, 0 skips
...............

Si vous voulez vérifier que votre modèle d'architecture est bien conforme
à ce qui est demandé, vous pouvez utiliser le programme de test suivant :

.Test du patron _Strategy_ sur les `Canard` en Ruby
[source,ruby]
----------
include::src/java/TD1/checkModel.rb[lines=8..200]
----------

=== Limitations

Si vous avez observé le diagramme obtenu, vous verrez qu'il n'y a pas
les associations (ni les dépendances). Plutôt que d'aller les rajouter
"à la main", vous pouvez utiliser les annotations plantUML, comme par exemple :

[source,java]
-------
/**
* @extends Controller
* @extends EmbeddedAgent
* @navassoc - - 1..* PowerManager
* @note this is a note
*/
class SetTopController implements URLStreamHandler {
  public String name;

  int authorizationLevel;
  void startUp() {}
    void shutDown() {}
      void connect() {}
      }
-------

Utilisez les annotations pour compléter vos codes Java de façon
à générer un diagramme de classe le plus complet possible.

[appendix]
[[plusloin]]
== Pour aller plus loin

. Testez les limites de votre implémentation (par exemple avez-vous pensé à
  ce qui se passe si quelqu'un fait un `new Chevalier(null,null)` ?).
. Vous pouvez imaginer une application graphique :-)
. Repérez la partie de votre application principale qui fait le lien entre une arme
donnée et le comportement à affecter au personnage. Comment pourrait-on améliorer cette
"correspondance"?
. À propos de `SuperCanardTest2` :
- c'est intéressant pour les méthodes qui produisent des lignes sur la sortie standard
- ça reste du test unitaire qui se rapproche du test fonctionnel
parce que l'on réécrit le `main()` dans les fonctions de test
- les méthodes produisent des messages sur la sortie standard. Bien sûr il aurait
été préférable qu'elles retournent des `String`
+
[NOTE]
=====
Java n'est pas l'idéal pour faire du test fonctionnel.
Ce serait plus simple de faire les tests fonctionnels avec python ou ruby
car ils sont proches de l'OS et plus efficaces pour faire toute sorte de _parsing_
et de _matching_. Utiliser un autre langage
pour les tests fonctionnels illustre aussi clairement qu'il s'agit de se placer
à l'extérieur du programme testé.
=====
- Notez l'utilisation d'une
expression régulière pour éviter les conflits d'OS pour le codage de la fin de
ligne. Notez que depuis Java 8 il existe un `\R` pour ça et que
qu'il existe aussi la possibilité d'utiliser `String System.getProperty("line.separator");`
pour les versions avant Java 7, et `System.lineSeparator()` depuis Java 7.


