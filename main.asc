// ------------------------------------------
//  Created by Jean-Michel Bruel on 2014-11.
//  Copyright (c) 2014 IRIT/U. Toulouse. All rights reserved.
// ------------------------------------------
= DUT-Info/S3/M3105 (CPOA)
Jean-Michel Bruel <jbruel@gmail.com>
v1.0, {localdate} - First draft
:status: bottom

// ------------------------------------------
include::definitions.txt[]
include::asciidoc.conf[]

== Introduction

Ce cours porte sur la **C**onception et **P**rogrammation **O**bjet **A**vancée.

ifdef::slides[:leveloffset: -1]

=== Concepts, bonnes pratiques et patrons

Vous avez appris (cf. M2103 et M2104) un certain nombre
de *concepts objets* :

[%step]
- Abstraction
- Encapsulation
- Polymorphisme
- Héritage

ifdef::slides[=== Concepts, bonnes pratiques et patrons (suite)]

Vous avez/allez ensuite appris des *bonnes pratiques* :

[%step]
- Identifier les aspects qui varient et les séparer des aspects constants
- Programmer une interface, non une implémentation
- Préférer la composition à l'héritage
- Les classes doivent être ouvertes à l'extension, mais fermées à la modification
- Dépendez d'abstractions. Ne dépendez pas de classes concrètes (inversion des dépendances)
- Ne parlez pas aux inconnus

ifdef::slides[=== Concepts, bonnes pratiques et patrons (suite)]

L'étape suivante consiste à apprendre les bonnes solutions de
conception, ce qu'on appelle les *patrons de conception*
(ou _design patterns_ en anglais).

=== Organisation

[NOTE]
====
Rappel du rythme : 1 cours, 1 TD et 2 TPs par semaine. Pendant 8 semaines.
====

[%step]
- La première semaine est consacré au principe des patrons
de conception, en partant d'un exemple (cours en fin de semaine).
- Les 5 suivantes sont consacrées à l'étude de certains patrons classiques.
Mise en pratique sur des exercices en TP.
+
[NOTE]
====
Les TPs sont décalés d'une semaine (conception et étude d'un ou
plusieurs patrons semaine `N` et mise en oeuvre en TP semaine `N+1`).
====
+
- Les 3 suivantes, les étudiants en mode projet pour faire du
_refactoring_ d'applications réelles (conception aidée en TD sur
les modèles {UML}, mise en oeuvre en TP).

ifdef::slides[=== Organisation (suite)]

Voici une proposition de déroulement des semaines :

Semaine 1::
  SuperCanard, le grand classique, <<Stratégie>>
Semaine 2::
  L'exemple de Meyer : menus en objet
Semaine 3::
   Premiers patrons
* <<Singleton>>
* <<Observateur>>
** version intuitive (2 interfaces)
** version Java (classe `Observable`)
Semaine 4::
  Patrons Fabrique, Proxy, Etat
Semaine 5::
  Patrons Décorateur, Façade, Visiteur
Semaine 6::
  - MVC avec l'exemple `JTable` de {java}
  - Patrons Chaîne de responsabilité (juste en cours)
Semaines 7 et 8::
  * Quelques idées de projet final :
  ** Refactorer un code généré par {umple}.
  ** Refactorer le code de MPA (mais pas le leur, celui d'un autre groupe)

=== Evaluation et notation

Comme prévu par le http://webetud2.iut-blagnac.fr/pluginfile.php/1653/mod_resource/content/4/Contr%C3%B4les-2014-2015_S3.pdf[planning des contrôles],
les étudiants auront :

- une note de projet (TPs + projet final) => coef. 1
- une note d'examen final (semaine 5) => coef. 2

ifdef::slides[:leveloffset: +1]

== Importance du typage

ifdef::slides[:leveloffset: -1]

=== Différents types de typage

Le fait d'attribuer un type (une classe) à une variable (un objet)
peut se faire de plusieurs façons :

- statique
- dynamique
- _duck typing_

=== Typage statique

On parle de *typage statique* quand la majorité des vérifications de type
sont effectuées au moment de la *compilation*.

.Exemple de typage statique
[source,C]
-----
int i = 0;  // cette déclaration indique explicitement que
            // la variable i est de type entier
-----

=== Typage dynamique

Le *typage dynamique* consiste à laisser l'ordinateur réaliser
l'opération de typage _à la volée_, *lors de l'exécution du code*.

ifdef::slides[=== Typage dynamique (exemple)]

.Exemple de typage dynamique
[source,java]
----
class A{
	int x;
}

class B extends A{
	int y;
}

...
A v1 = new B();
B v2 = (B) v1;
----

=== _Duck typing_

Style de *typage dynamique* où la *sémantique* d'un objet (c'est-à-dire son type)
est déterminée par l'ensemble de ses *méthodes* et de ses *attributs*,
et non par un type défini et nommé explicitement par le programmeur.

[NOTE]
======
L'origine de cette expression est liée à cette citation :
[quote, James Whitcomb Riley]
____________________________________________________________________
Si je vois un animal qui vole comme un canard, cancane comme un canard,
et nage comme un canard, alors j'appelle cet oiseau un canard.
____________________________________________________________________
======

ifdef::slides[=== _Duck typing_ (exemple)]

.Exemple de _duck typing_
[source,ruby]
-----
function calcule(a, b, c) => return (a+b)*c

a = calcule (1, 2, 3)
b = calcule ('pommes ', 'et oranges, ', 3)

print to_string a
print to_string b
-----

Ce qui donne :

......
9
"pommes et oranges, pommes et oranges, pommes et oranges, "
......

TIP: Pour aller plus loin : http://fr.wikipedia.org/wiki/Duck_typing[]

ifdef::slides[:leveloffset: +1]

== Importance de la visibilité

Dès que l'on commence à avoir une application conséquente, l'organisation
en _package_ devient obligatoire. Revenons donc sur les questions de
*visibilité* des propriétés et méthodes, qui seront importants dans la plupart
des aspects de ce module.

Si un champ d'une classe `A` :

- est _private_, il est accessible uniquement depuis sa propre classe ;
- a la visibilité _package_ (par défaut), il est accessible de partout dans
le paquetage de `A` mais de nulle part ailleurs ;
- est _protected_, il est accessible de partout dans le paquetage de `A` et,
si `A` est publique, grosso modo dans les classes héritant de `A` dans d'autres
paquetages ;
- est _public_, il est accessible de partout dans le paquetage de `A` et,
si `A` est publique, de partout ailleurs.

NOTE: Ci-dessus, les niveaux de visibilité sont rangés par visibilité croissante.

ifdef::slides[== Importance de la visibilité (exemple)]

[source,java]
----
package UN;
public class A {
  protected String attrprotected;
  String attrfriend; // friend
}
----

Si on définit une deuxième classe dans le même _package_ :

[source,java]
----
package UN;
class B {
  ...
{
    A a = new A ();
    a.attrprotected// OK : même si bizarre
    a.attrfriend  // OK : visible package
}
}

package UN;
class C extends A {
...
{
    this.attrprotected// OK : normal
    this.attrfriend // OK : visible package
}
}
----

ifdef::slides[== Importance de la visibilité (suite de l'exemple)]

[source,java]
----
package DEUX;
class B {
  ...
{
    A a = new A ();
    a.attrprotected// NON OK : normal
    a.attrfriend  // NON OK : normal, proche de "private"
}
}

class C extends A {
  ...
{
    this.attrprotected// OK : normal car protected et héritage
    this.attrfriend // NON OK : normal, proche de "private"
}
}
----

ifdef::slides[== Visibilité et UML]

NOTE: Il n'y a pas de visibilité par défaut en {UML}.

include::patterns.asc[leveloffset=+1]

:numbered!:
include::glossaire.txt[]

include::refs.txt[]

:numbered!:
== About...

****************************************************************
Document réalisé par mailto:{email}[{author}] via  {asciidoctorlink} (version `{asciidoctor-version}`) de 'Dan Allen', lui même basé sur {asciidoc}.
Pour l'instant ce document est libre d'utilisation et géré par la 'Licence Creative Commons'.
image:88x31.png["Licence Creative
Commons",style="border-width:0",link="http://creativecommons.org/licenses/by-sa/3.0/"]
http://creativecommons.org/licenses/by-sa/3.0/[licence Creative Commons Paternité - Partage à l&#39;Identique 3.0 non transposé].
****************************************************************
